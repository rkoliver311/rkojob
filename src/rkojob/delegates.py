# Copyright (c) 2025 R.K. Oliver. All rights reserved.
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

from __future__ import annotations

from typing import Any, Callable, Generic, Iterable, Iterator, ParamSpec, TypeVar

P = ParamSpec("P")
R = TypeVar("R")

CallbackType = Callable[P, R]


class DelegateException(Exception):
    """
    An exception raised when a callback fails and continue_on_error is not True.
    """

    def __init__(self, error: Exception, *, results: list[Any | None] | None = None):
        super().__init__(error)
        self.error: Exception = error
        """The error raised by the callback."""
        self.results: list[Any] | None = results
        """The results generated by the delegate's callbacks."""


class Delegate(Iterable[CallbackType], Generic[P, R]):
    """
    Class that allows one or more callbacks to be invoked.
    """

    def __init__(self, continue_on_error: bool | None = None, reverse: bool | None = None):
        """
        Create a new Delegate instance.
        :param continue_on_error: Whether to continue invoking callbacks when a callback raises an error. When set to
         False, a DelegateException exception will be raised and no further callbacks will be invoked. Defaults to True.
        :param reverse: Invoke callbacks in reverse order.
        """
        self._callbacks: list[CallbackType] = []
        if continue_on_error is None:
            continue_on_error = False
        self._continue_on_error: bool = continue_on_error
        if reverse is None:
            reverse = False
        self._reverse: bool = reverse

    def add_callback(self, callback: CallbackType):
        """
        Add a callback to this delegate. The callback will be invoked when the delegate is called.
        :param callback: The callback to add to this delegate's list of callbacks. The callback must be callable. If the
         callback is already present in the list it is moved to the end.
        """
        if not callable(callback):
            raise ValueError("callback must be callable")
        # Remove the function if it already
        # exists in the list of callbacks.
        self.remove_callback(callback)
        if self._reverse:
            self._callbacks.insert(0, callback)
        else:
            self._callbacks.append(callback)

    def remove_callback(self, callback: CallbackType):
        if callback in self._callbacks:
            self._callbacks.remove(callback)

    def __iadd__(self, other: CallbackType | Delegate[P, R]) -> Delegate[P, R]:
        if isinstance(other, Delegate):
            for callback in other:
                self.add_callback(callback)
        else:
            self.add_callback(other)
        return self

    def __isub__(self, other: CallbackType | Delegate[P, R]) -> Delegate[P, R]:
        if isinstance(other, Delegate):
            for callback in other:
                self.remove_callback(callback)
        else:
            self.remove_callback(other)
        return self

    def __add__(self, other: CallbackType | Delegate[P, R]) -> Delegate[P, R]:
        result: Delegate[P, R] = Delegate(continue_on_error=self._continue_on_error, reverse=self._reverse)
        for callback in self:
            result.add_callback(callback)
        if isinstance(other, Delegate):
            for callback in other:
                result.add_callback(callback)
        else:
            result.add_callback(other)
        return result

    def __radd__(self, other: CallbackType) -> Delegate[P, R]:
        return self + other

    def __sub__(self, other: CallbackType | Delegate[P, R]) -> Delegate[P, R]:
        result: Delegate[P, R] = Delegate(continue_on_error=self._continue_on_error, reverse=self._reverse)
        for callback in self:
            result.add_callback(callback)
        if isinstance(other, Delegate):
            for callback in other:
                result.remove_callback(callback)
        else:
            result.remove_callback(other)
        return result

    def __bool__(self) -> bool:
        return bool(self._callbacks)

    def __iter__(self) -> Iterator[CallbackType]:
        return iter(self._callbacks)

    def __call__(self, *arg: P.args, **kwargs: P.kwargs) -> list[R | Exception | None]:
        """
        Invokes all callbacks in series and returns the result of each. If a callback raises an error it is included
        in the result list.
        :param *args: The parameters to pass to each callback.
        :param **kwargs: The keyword parameters to pass to each callback.
        :returns: A list of the results from each of the callbacks.
        """
        results: list[R | Exception | None] = [None] * len(self._callbacks)
        for index, callback in enumerate(self):
            try:
                results[index] = callback(*arg, **kwargs)
            except Exception as e:
                results[index] = e
                if not self._continue_on_error:
                    raise DelegateException(e, results=results) from e
        return results


def delegate(*args, **kwargs):
    def _decorator(func: Callable[P, R]) -> property:
        name = func.__name__
        attr_name = f"_{name}_delegate"

        def wrapper(self) -> Delegate[P, R]:
            if not hasattr(self, attr_name):
                setattr(self, attr_name, Delegate[P, R](**kwargs))
            return getattr(self, attr_name)

        def setter(self, value: Delegate[P, R]) -> None:
            current = wrapper(self)
            if value is not current:
                raise AttributeError(f"Cannot reassign delegate '{name}'. Use '+=' to add handlers.")
            # allow noop assignment (needed for foo.teardown += x)

        return property(wrapper, setter)

    if len(args) == 1 and callable(args[0]):
        return _decorator(args[0])
    return _decorator
