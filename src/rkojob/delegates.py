from __future__ import annotations

from typing import Any, Callable, Generic, ParamSpec, TypeVar

P = ParamSpec("P")
R = TypeVar("R")

CallbackType = Callable[P, R]


class DelegateException(Exception):
    """
    An exception raised when a callback fails and continue_on_error is not True.
    """

    def __init__(self, error: Exception, *, results: list[Any | None] | None = None):
        super().__init__(error)
        self.error: Exception = error
        """The error raised by the callback."""
        self.results: list[Any] | None = results
        """The results generated by the delegate's callbacks."""


class Delegate(Generic[P, R]):
    """
    Class that allows one or more callbacks to be invoked.
    """

    def __init__(self, continue_on_error: bool | None = None, reverse: bool | None = None):
        """
        Create a new Delegate instance.
        :param continue_on_error: Whether to continue invoking callbacks when a callback raises an error. When set to
         False, a DelegateException exception will be raised and no further callbacks will be invoked. Defaults to True.
        :param reverse: Invoke callbacks in reverse order.
        """
        self._callbacks: list[CallbackType] = []
        if continue_on_error is None:
            continue_on_error = False
        self._continue_on_error: bool = continue_on_error

        if reverse is None:
            reverse = False
        self._reverse: bool = reverse

    def add_callback(self, callback: CallbackType):
        """
        Add a callback to this delegate. The callback will be invoked when the delegate is called.
        :param callback: The callback to add to this delegate's list of callbacks. The callback must be callable. If the
         callback is already present in the list it is moved to the end.
        """
        if not callable(callback):
            raise ValueError("callback must be callable")
        # Remove the function if it already
        # exists in the list of callbacks.
        self.remove_callback(callback)
        self._callbacks.append(callback)

    def remove_callback(self, callback: CallbackType):
        if callback in self._callbacks:
            self._callbacks.remove(callback)

    def __call__(self, *arg: P.args, **kwargs: P.kwargs) -> list[R | Exception | None]:
        """
        Invokes all callbacks in series and returns the result of each. If a callback raises an error it is included
        in the result list.
        :param *args: The parameters to pass to each callback.
        :param **kwargs: The keyword parameters to pass to each callback.
        :returns: A list of the results from each of the callbacks.
        """
        results: list[R | Exception | None] = [None] * len(self._callbacks)

        indexes: range
        if self._reverse:
            indexes = range(len(self._callbacks) - 1, -1, -1)
        else:
            indexes = range(len(self._callbacks))

        for idx in indexes:
            callback: CallbackType = self._callbacks[idx]
            try:
                results[idx] = callback(*arg, **kwargs)
            except Exception as e:
                results[idx] = e
                if not self._continue_on_error:
                    raise DelegateException(e, results=results) from e
        return results


def delegate(*args, **kwargs):
    def _decorator(func: Callable[P, R]) -> property:
        name = func.__name__
        attr_name = f"_{name}_delegate"

        def wrapper(self) -> Delegate[P, R]:
            if not hasattr(self, attr_name):
                setattr(self, attr_name, Delegate[P, R](**kwargs))
            return getattr(self, attr_name)

        return property(wrapper)

    if len(args) == 1 and callable(args[0]):
        return _decorator(args[0])
    return _decorator
